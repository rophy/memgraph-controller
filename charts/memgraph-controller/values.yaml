image:
  repository: memgraph-controller
  tag: latest
  pullPolicy: IfNotPresent

# High Availability Configuration
# Controller always supports HA with leader election
# Default: 3 replicas for production HA deployment
# Set replicas: 1 for single-instance development/testing
replicas: 3

# Leader election configuration
leaderElection:
  # Resource lock lease duration (how long a leader holds the lock)
  leaseDuration: 15s
  # Deadline for renewing the leadership lock
  renewDeadline: 10s
  # Retry period for leader election
  retryPeriod: 2s

env:
  APP_NAME: memgraph
  NAMESPACE: memgraph
  RECONCILE_INTERVAL: 30s
  BOLT_PORT: "7687"
  SERVICE_NAME: memgraph
  HTTP_PORT: "8080"
  # STATEFULSET_NAME will be set automatically based on the target memgraph release name
  # For example: if user installs memgraph with "helm install my-db memgraph/memgraph"
  # then STATEFULSET_NAME should be "my-db-memgraph" to match the StatefulSet name

# Resource requirements
# For HA mode, consider increasing requests:
#   requests:
#     cpu: 200m
#     memory: 256Mi
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

serviceAccount:
  create: true
  annotations: {}
  name: ""

rbac:
  create: true

nodeSelector: {}

tolerations: []

# Pod anti-affinity to spread replicas across nodes (recommended for HA)
# Uncomment for HA deployment:
affinity: {}
  # podAntiAffinity:
  #   preferredDuringSchedulingIgnoredDuringExecution:
  #   - weight: 100
  #     podAffinityTerm:
  #       labelSelector:
  #         matchExpressions:
  #         - key: app.kubernetes.io/name
  #           operator: In
  #           values:
  #           - memgraph-controller
  #       topologyKey: kubernetes.io/hostname

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# Logging configuration
log:
  level: info
  format: json

# Status API configuration
statusApi:
  enabled: true
  port: 8080
  path: /api/v1/status

# Health check configuration
health:
  port: 8080
  path: /health

# Metrics configuration
metrics:
  enabled: false
  port: 8081
  path: /metrics

# Gateway configuration
gateway:
  enabled: true
  bindAddress: "0.0.0.0:7687"
  maxConnections: 1000
  timeout: 30s
  bufferSize: 32768
  
  # Connection management
  healthCheckInterval: 30s
  connectionTimeout: 10s
  idleTimeout: 5m
  maxBytesPerConnection: 1073741824  # 1GB
  cleanupInterval: 1m
  
  # TLS configuration
  tls:
    enabled: false
    certPath: /etc/certs/tls.crt
    keyPath: /etc/certs/tls.key
    # When enabled, mount certificates from a secret
    secretName: ""  # Set to secret name to enable TLS certificate mounting
  
  # Rate limiting
  rateLimit:
    enabled: true
    rps: 100
    burst: 200
    window: 1m
  
  # Logging
  logLevel: info
  traceEnabled: false
  
  # Service configuration for gateway
  service:
    type: LoadBalancer
    port: 7687
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
      service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
      service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    # For production with TLS:
    # annotations:
    #   service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:region:account:certificate/cert-id"
    #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"